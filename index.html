<!doctype html>
<html>
  <head>
    <title>GFX 128x32</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  </head>
  <body>
    <canvas
      id="canvas"
      style="width: 22mm; image-rendering: pixelated"
    ></canvas>
    <select title="Demo selection" id="select"></select>

    <script>
      class AdafruitGFX {
        constructor(canvasId, width = 128, height = 32) {
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext("2d");
          this.ctx.imageSmoothingEnabled = false;
          this.width = width;
          this.height = height;
          this.canvas.width = width;
          this.canvas.height = height;

          // Text properties
          this.cursorX = 0;
          this.cursorY = 0;
          this.textColor = 0xffff; // WHITE
          this.textBgColor = null;
          this.textSize = 1;
          this.textWrap = true;
          this.charWidth = 6;
          this.charHeight = 8;

          // Animation properties
          this.animationRunning = false;
          this.animationId = null;
          this.previousTimestamp = null;

          // Clear canvas
          this.clearDisplay();
        }

        // RGB565 Color definitions
        static get BLACK() {
          return 0x0000;
        }
        static get BLUE() {
          return 0x001f;
        }
        static get RED() {
          return 0xf800;
        }
        static get GREEN() {
          return 0x07e0;
        }
        static get CYAN() {
          return 0x07ff;
        }
        static get MAGENTA() {
          return 0xf81f;
        }
        static get YELLOW() {
          return 0xffe0;
        }
        static get WHITE() {
          return 0xffff;
        }

        // Helper function to create RGB565 color from RGB888
        static color565(r, g, b) {
          return ((r & 0xf8) << 8) | ((g & 0xfc) << 3) | (b >> 3);
        }

        // Convert RGB565 to CSS color string
        colorToCSS(color) {
          // If it's already a string, return it
          if (typeof color === "string") return color;

          // Handle RGB565 format (16-bit color)
          if (typeof color === "number") {
            // Extract 5-6-5 bits
            const r5 = (color >> 11) & 0x1f; // 5 bits for red
            const g6 = (color >> 5) & 0x3f; // 6 bits for green
            const b5 = color & 0x1f; // 5 bits for blue

            // Convert to 8-bit values (0-255)
            // Scale up by replicating the high bits into the low bits
            const r8 = (r5 << 3) | (r5 >> 2);
            const g8 = (g6 << 2) | (g6 >> 4);
            const b8 = (b5 << 3) | (b5 >> 2);

            return `rgb(${r8}, ${g8}, ${b8})`;
          }

          return color;
        }

        // Drawing primitives
        drawPixel(x, y, color) {
          this.ctx.fillStyle = this.colorToCSS(color);
          this.ctx.fillRect(Math.floor(x), Math.floor(y), 1, 1);
        }

        drawLine(x0, y0, x1, y1, color) {
          this.ctx.strokeStyle = this.colorToCSS(color);
          this.ctx.lineWidth = 1;
          this.ctx.beginPath();
          this.ctx.moveTo(Math.floor(x0) + 0.5, Math.floor(y0) + 0.5);
          this.ctx.lineTo(Math.floor(x1) + 0.5, Math.floor(y1) + 0.5);
          this.ctx.stroke();
        }

        drawFastVLine(x, y, length, color) {
          this.ctx.fillStyle = this.colorToCSS(color);
          this.ctx.fillRect(Math.floor(x), Math.floor(y), 1, length);
        }

        drawFastHLine(x, y, length, color) {
          this.ctx.fillStyle = this.colorToCSS(color);
          this.ctx.fillRect(Math.floor(x), Math.floor(y), length, 1);
        }

        // Rectangles
        drawRect(x, y, w, h, color) {
          this.ctx.strokeStyle = this.colorToCSS(color);
          this.ctx.lineWidth = 1;
          this.ctx.strokeRect(
            Math.floor(x) + 0.5,
            Math.floor(y) + 0.5,
            w - 1,
            h - 1,
          );
        }

        fillRect(x, y, w, h, color) {
          this.ctx.fillStyle = this.colorToCSS(color);
          this.ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
        }

        // Circles
        drawCircle(x, y, r, color) {
          this.ctx.strokeStyle = this.colorToCSS(color);
          this.ctx.lineWidth = 1;
          this.ctx.beginPath();
          this.ctx.arc(
            Math.floor(x) + 0.5,
            Math.floor(y) + 0.5,
            r,
            0,
            2 * Math.PI,
          );
          this.ctx.stroke();
        }

        fillCircle(x, y, r, color) {
          this.ctx.fillStyle = this.colorToCSS(color);
          this.ctx.beginPath();
          this.ctx.arc(
            Math.floor(x) + 0.5,
            Math.floor(y) + 0.5,
            r,
            0,
            2 * Math.PI,
          );
          this.ctx.fill();
        }

        // Rounded rectangles
        drawRoundRect(x, y, w, h, radius, color) {
          this.ctx.strokeStyle = this.colorToCSS(color);
          this.ctx.lineWidth = 1;
          this.ctx.beginPath();
          this.roundRectPath(x, y, w, h, radius);
          this.ctx.stroke();
        }

        fillRoundRect(x, y, w, h, radius, color) {
          this.ctx.fillStyle = this.colorToCSS(color);
          this.ctx.beginPath();
          this.roundRectPath(x, y, w, h, radius);
          this.ctx.fill();
        }

        roundRectPath(x, y, w, h, radius) {
          x = Math.floor(x);
          y = Math.floor(y);
          this.ctx.moveTo(x + radius, y);
          this.ctx.lineTo(x + w - radius, y);
          this.ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
          this.ctx.lineTo(x + w, y + h - radius);
          this.ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
          this.ctx.lineTo(x + radius, y + h);
          this.ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
          this.ctx.lineTo(x, y + radius);
          this.ctx.quadraticCurveTo(x, y, x + radius, y);
        }

        // Triangles
        drawTriangle(x0, y0, x1, y1, x2, y2, color) {
          this.ctx.strokeStyle = this.colorToCSS(color);
          this.ctx.lineWidth = 1;
          this.ctx.beginPath();
          this.ctx.moveTo(Math.floor(x0) + 0.5, Math.floor(y0) + 0.5);
          this.ctx.lineTo(Math.floor(x1) + 0.5, Math.floor(y1) + 0.5);
          this.ctx.lineTo(Math.floor(x2) + 0.5, Math.floor(y2) + 0.5);
          this.ctx.closePath();
          this.ctx.stroke();
        }

        fillTriangle(x0, y0, x1, y1, x2, y2, color) {
          this.ctx.fillStyle = this.colorToCSS(color);
          this.ctx.beginPath();
          this.ctx.moveTo(Math.floor(x0), Math.floor(y0));
          this.ctx.lineTo(Math.floor(x1), Math.floor(y1));
          this.ctx.lineTo(Math.floor(x2), Math.floor(y2));
          this.ctx.closePath();
          this.ctx.fill();
        }

        // Text functions
        setCursor(x, y) {
          this.cursorX = x;
          this.cursorY = y;
        }

        setTextColor(color, bgColor = null) {
          this.textColor = color;
          this.textBgColor = bgColor;
        }

        setTextSize(size) {
          this.textSize = size;
        }

        setTextWrap(wrap) {
          this.textWrap = wrap;
        }

        drawChar(x, y, c, color, bgColor, size) {
          const charW = this.charWidth * size;
          const charH = this.charHeight * size;

          // Draw background if specified
          if (bgColor !== undefined && bgColor !== null) {
            this.ctx.fillStyle = this.colorToCSS(bgColor);
            this.ctx.fillRect(x, y, charW, charH);
          }

          // Draw character
          this.ctx.fillStyle = this.colorToCSS(color);
          this.ctx.font = `${size}px Micro5`;
          this.ctx.textBaseline = "top";
          this.ctx.fillText(c, x, y);
        }

        print(text) {
          const str = String(text);
          const charW = this.textSize;
          const charH = this.textSize;

          for (let i = 0; i < str.length; i++) {
            const c = str[i];

            // Handle newline
            if (c === "\n") {
              this.cursorX = 0;
              this.cursorY += charH;
              continue;
            }

            // Handle text wrapping
            if (this.textWrap && this.cursorX + charW > this.width) {
              this.cursorX = 0;
              this.cursorY += charH;
            }

            // Draw character
            this.drawChar(
              this.cursorX,
              this.cursorY,
              c,
              this.textColor,
              this.textBgColor,
              this.textSize,
            );

            this.cursorX += charW;
          }
        }

        println(text) {
          this.print(text);
          this.cursorX = 0;
          this.cursorY += this.charHeight * this.textSize;
        }

        // Utility functions
        clearDisplay() {
          this.ctx.fillStyle = this.colorToCSS(AdafruitGFX.BLACK);
          this.ctx.fillRect(0, 0, this.width, this.height);
        }

        display() {
          // In actual hardware this would push buffer to display
          // For canvas, rendering is immediate
        }
        drawBitmap(x, y, bitmap, w, h, color) {
          // Ensure bitmap is an array or typed array
          if (!Array.isArray(bitmap) && !(bitmap instanceof Uint8Array)) {
            console.error("Bitmap must be an array or Uint8Array");
            return;
          }

          const bytesPerRow = Math.ceil(w / 8);

          for (let j = 0; j < h; j++) {
            for (let i = 0; i < w; i++) {
              const byteIndex = j * bytesPerRow + Math.floor(i / 8);
              const bitIndex = 7 - (i % 8); // MSB first

              if (byteIndex < bitmap.length) {
                const byte = bitmap[byteIndex];
                const bit = (byte >> bitIndex) & 1;

                if (bit) {
                  this.drawPixel(x + i, y + j, color);
                }
              }
            }
          }
        }

        // Animation methods
        startAnimation(callback) {
          this.animationRunning = true;
          const animate = (timestamp) => {
            if (!this.animationRunning) return;
            let delta = null;
            if (this.previousTimestamp !== null) {
              delta = timestamp - this.previousTimestamp;
            }

            callback(timestamp, delta);

            this.animationId = requestAnimationFrame(animate);
            this.previousTimestamp = timestamp;
          };
          this.animationId = requestAnimationFrame(animate);
        }

        stopAnimation() {
          this.animationRunning = false;
          if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
          }
        }
      }

      // Example animations with proper RGB565 colors:

      // 1. Bouncing Ball Animation
      function bouncingBallDemo() {
        const gfx = new AdafruitGFX("canvas", 128, 32);

        let x = 64;
        let y = 16;
        let vx = 2;
        let vy = 1.5;
        const radius = 4;

        gfx.startAnimation((timestamp, delta) => {
          // Clear display
          gfx.clearDisplay();

          delta /= 10;

          // Update position
          x += delta * vx;
          y += delta * vy;

          // Bounce off walls
          if (x - radius <= 0 || x + radius >= gfx.width) {
            vx = -vx;
            x = Math.max(radius, Math.min(gfx.width - radius, x));
          }
          if (y - radius <= 0 || y + radius >= gfx.height) {
            vy = -vy;
            y = Math.max(radius, Math.min(gfx.height - radius, y));
          }

          // Draw ball
          gfx.fillCircle(x, y, radius, AdafruitGFX.GREEN);

          // Draw border
          gfx.drawRect(0, 0, gfx.width, gfx.height, AdafruitGFX.WHITE);

          // Display info
          gfx.setCursor(2, 2);
          gfx.setTextColor(AdafruitGFX.YELLOW, AdafruitGFX.BLACK);
          gfx.setTextSize(1);
          gfx.print("Ball");
        });

        return gfx;
      }

      // 2. Rotating Shapes Animation
      function rotatingShapesDemo() {
        const gfx = new AdafruitGFX("canvas", 128, 32);

        let angle = 0;
        const centerX = 64;
        const centerY = 16;

        gfx.startAnimation((timestamp) => {
          // Clear display
          gfx.clearDisplay();

          angle += 0.02;

          // Draw rotating triangle
          const r = 12;
          const x1 = centerX + r * Math.cos(angle);
          const y1 = centerY + r * Math.sin(angle);
          const x2 = centerX + r * Math.cos(angle + 2.094);
          const y2 = centerY + r * Math.sin(angle + 2.094);
          const x3 = centerX + r * Math.cos(angle + 4.189);
          const y3 = centerY + r * Math.sin(angle + 4.189);

          gfx.fillTriangle(x1, y1, x2, y2, x3, y3, AdafruitGFX.MAGENTA);

          // Draw rotating circle outline
          const cx = centerX + 20 * Math.cos(angle * 2);
          const cy = centerY + 8 * Math.sin(angle * 2);
          gfx.drawCircle(cx, cy, 5, AdafruitGFX.CYAN);
        });

        return gfx;
      }

      // 3. Scrolling Text Animation
      function scrollingTextDemo() {
        const gfx = new AdafruitGFX("canvas", 128, 32);

        let scrollX = gfx.width;
        const message = "Hello from Adafruit GFX!";
        const messageWidth = message.length * 10; // 6 pixels per char

        gfx.startAnimation((timestamp) => {
          // Clear display
          gfx.clearDisplay();

          // Update scroll position
          scrollX = gfx.width - ((timestamp / 10) % (gfx.width + messageWidth));

          // Draw scrolling text
          gfx.setCursor(scrollX, 12);
          gfx.setTextColor(AdafruitGFX.GREEN);
          gfx.setTextSize(1);
          gfx.drawChar(scrollX, 5, message, AdafruitGFX.WHITE, undefined, 30);

          // Draw decorative lines
          gfx.drawFastHLine(0, 0, gfx.width, AdafruitGFX.RED);
          gfx.drawFastHLine(0, gfx.height - 1, gfx.width, AdafruitGFX.RED);
        });

        return gfx;
      }

      // 4. Wave Pattern Animation
      function wavePatternDemo() {
        const gfx = new AdafruitGFX("canvas", 128, 32);

        let phase = 0;

        gfx.startAnimation((timestamp) => {
          // Clear display
          gfx.clearDisplay();

          phase += 0.05;

          // Draw wave pattern
          for (let x = 0; x < gfx.width; x += 2) {
            const y = gfx.height / 2 + Math.sin(x * 0.1 + phase) * 10;
            gfx.fillCircle(x, y, 2, AdafruitGFX.BLUE);
          }

          // Draw counter
          gfx.setCursor(2, 2);
          gfx.setTextColor(AdafruitGFX.YELLOW, AdafruitGFX.BLACK);
          gfx.setTextSize(1);
          gfx.print("Wave");
        });

        return gfx;
      }

      // 5. Rainbow Color Cycle Animation
      function rainbowDemo() {
        const gfx = new AdafruitGFX("canvas", 128, 32);

        let hue = 0;

        // Helper function to convert HSV to RGB565
        function hsvToRgb565(h, s, v) {
          const c = v * s;
          const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
          const m = v - c;

          let r, g, b;
          if (h < 60) {
            r = c;
            g = x;
            b = 0;
          } else if (h < 120) {
            r = x;
            g = c;
            b = 0;
          } else if (h < 180) {
            r = 0;
            g = c;
            b = x;
          } else if (h < 240) {
            r = 0;
            g = x;
            b = c;
          } else if (h < 300) {
            r = x;
            g = 0;
            b = c;
          } else {
            r = c;
            g = 0;
            b = x;
          }

          const r8 = Math.round((r + m) * 255);
          const g8 = Math.round((g + m) * 255);
          const b8 = Math.round((b + m) * 255);

          return AdafruitGFX.color565(r8, g8, b8);
        }

        gfx.startAnimation((timestamp) => {
          // Clear display
          gfx.clearDisplay();

          hue = (timestamp / 5) % 360;

          // Draw rainbow bars
          for (let i = 0; i < 8; i++) {
            const barHue = (hue + i * 45) % 360;
            const color = hsvToRgb565(barHue, 1, 1);
            gfx.fillRect(i * 16, 8, 16, 16, color);
          }

          // Draw text
          gfx.setCursor(35, 0);
          gfx.setTextColor(AdafruitGFX.WHITE, AdafruitGFX.BLACK);
          gfx.setTextSize(1);
          gfx.print("RAINBOW");
        });

        return gfx;
      }

      // 6. Multi-Demo Showcase
      function showcaseDemo() {
        const gfx = new AdafruitGFX("canvas", 128, 32);

        let frame = 0;

        gfx.startAnimation((timestamp) => {
          gfx.clearDisplay();

          frame++;
          const t = frame / 60;

          // Rotating rectangle
          const rectSize = 8 + Math.sin(t) * 4;
          gfx.fillRect(10, 12, rectSize, rectSize, AdafruitGFX.RED);

          // Pulsing circle
          const circleR = 4 + Math.abs(Math.sin(t * 2)) * 3;
          gfx.fillCircle(40, 16, circleR, AdafruitGFX.GREEN);

          // Moving triangle
          const triX = 60 + Math.sin(t * 1.5) * 10;
          gfx.fillTriangle(
            triX,
            8,
            triX + 8,
            8,
            triX + 4,
            16,
            AdafruitGFX.BLUE,
          );

          // Blinking text
          if (Math.floor(t * 2) % 2 === 0) {
            gfx.setCursor(85, 12);
            gfx.setTextColor(AdafruitGFX.YELLOW);
            gfx.setTextSize(1);
            gfx.print("GFX");
          }

          // Border
          gfx.drawRect(0, 0, gfx.width, gfx.height, AdafruitGFX.WHITE);

          // Frame counter
          gfx.setCursor(2, 2);
          gfx.setTextColor(AdafruitGFX.CYAN, AdafruitGFX.BLACK);
          gfx.setTextSize(1);
          gfx.print(frame);
        });

        return gfx;
      }

      function flag() {
        const gfx = new AdafruitGFX("canvas", 128, 32);

        let frame = 0;

        gfx.startAnimation((timestamp) => {
          gfx.clearDisplay();
          const t = timestamp / 140;
          const amplitude = 1.25;
          const speed = -1 / 2;
          const frequency = 1 / 6;
          const crossPaddingX = 5;
          const crossPaddingY = 5;
          const crossInnerWidth = 6;
          const crossOuterWidth = crossInnerWidth * 3;
          const crossInnerRem = (crossOuterWidth - crossInnerWidth) / 2;
          const flagWidth = 2 * crossPaddingX + crossOuterWidth;
          const flagHeight = 2 * crossPaddingY + crossOuterWidth;

          for (let x = 0; x < flagWidth; x++) {
            let y =
              amplitude *
              (Math.sin(frequency * x + speed * t) - Math.sin(speed * t));
            for (let yOffset = 0; yOffset < flagHeight; yOffset++) {
              roundedY = Math.round(y) + yOffset;
              const isCross =
                (x >= crossPaddingX &&
                  x < flagWidth - crossPaddingX &&
                  yOffset >= crossPaddingY + crossInnerRem &&
                  yOffset < flagHeight - crossPaddingY - crossInnerRem) ||
                (x >= crossPaddingX + crossInnerRem &&
                  x < flagWidth - crossPaddingX - crossInnerRem &&
                  yOffset >= crossPaddingY &&
                  yOffset < flagHeight - crossPaddingY);
              if (!isCross) {
                gfx.drawPixel(x + 2, roundedY + 2, AdafruitGFX.WHITE);
              }
            }
          }
          gfx.drawLine(2, 10, 2, 128, AdafruitGFX.WHITE);
        });
      }

      // Multiple sprites demo
      function spriteSheetDemo() {
        const gfx = new AdafruitGFX("canvas", 32, 128);

        // Define multiple small sprites
        const heartBitmap = [
          0b00000000, 0b01100110, 0b11111111, 0b11111111, 0b11111111,
          0b01111110, 0b00111100, 0b00011000,
        ];

        const starBitmap = [
          0b00010000, 0b00111000, 0b01111100, 0b11111110, 0b01111100,
          0b00111000, 0b00010000, 0b00000000,
        ];

        let time = 0;

        gfx.startAnimation((timestamp) => {
          // Clear display
          gfx.fillRect(0, 0, gfx.width, gfx.height, AdafruitGFX.BLACK);

          time += 0.05;

          // Draw multiple animated sprites
          for (let i = 0; i < 5; i++) {
            const spriteX = 5 + i * 25;
            const spriteY = 8 + Math.sin(time + i) * 5;
            const color = i % 2 === 0 ? AdafruitGFX.WHITE : AdafruitGFX.CYAN;

            if (i % 2 === 0) {
              gfx.drawBitmap(spriteX, spriteY, heartBitmap, 8, 8, color);
            } else {
              gfx.drawBitmap(spriteX, spriteY, starBitmap, 8, 8, color);
            }
          }

          // Draw info
          gfx.setCursor(2, 25);
          gfx.setTextColor(gfx.WHITE);
          gfx.setTextSize(8);
          gfx.print("Sprites: " + Math.floor(time));
        });

        return gfx;
      }

      function ui() {
        const shield = {
          data: [
            0x1f, 0xc0, 0x7f, 0xf0, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xc0,
            0x18, 0xc0, 0x18, 0xc0, 0x18, 0xf8, 0xf8, 0x78, 0xf0, 0x38, 0xe0,
            0x1f, 0xc0, 0x0f, 0x80, 0x07, 0x00,
          ],
          width: 13,
          height: 14,
        };
        const bigCross = {
          data: [
            0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x3f,
            0xe0, 0x3f, 0xe0, 0x3f, 0xe0, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          ],
          width: 13,
          height: 14,
        };
        const smallFlag = {
          data: [0xf8, 0xd8, 0x88, 0xd8, 0xf8],
          width: 5,
          height: 5,
        };
        const smallCross = {
          data: [0x00, 0x20, 0x70, 0x20, 0x00],
          width: 5,
          height: 5,
        };
        const gfx = new AdafruitGFX("canvas", 128, 32);
        let selected = 0;
        const menuItems = ["A Alarm", "C Alarm", "Pager", "Hymne"]; //new Array(25).fill("").map((_, i) => i.toString(7)) //
        const menuItemCount = menuItems.length;
        const menuItemsPerCol = 2;
        const selectedBitmap = shield;
        const unselectedBitmap = bigCross;
        function render() {
          gfx.fillRect(0, 0, gfx.width, gfx.height, AdafruitGFX.BLACK);

          for (let i = 0; i < menuItemCount; i++) {
            const x =
              2 +
              Math.floor(i / menuItemsPerCol) *
                Math.floor(
                  gfx.width / Math.ceil(menuItemCount / menuItemsPerCol),
                );
            const y =
              (i % menuItemsPerCol) * Math.floor(gfx.height / menuItemsPerCol) +
              1;
            const bitmap = i === selected ? selectedBitmap : unselectedBitmap;
            gfx.drawBitmap(
              x,
              y,
              bitmap.data,
              bitmap.width,
              bitmap.height,
              AdafruitGFX.WHITE,
            );
            gfx.setCursor();
            gfx.setTextColor(gfx.WHITE);
            gfx.setTextSize(30);
            gfx.drawChar(
              x + bitmap.width + 2,
              y - 2,
              menuItems[i],
              gfx.WHITE,
              undefined,
              Math.floor(gfx.height / menuItemsPerCol) + 5,
            );
          }
        }

        gfx.startAnimation(() => {
          render();
        });

        render();

        document.addEventListener("keydown", (event) => {
          switch (event.key) {
            case "ArrowDown":
              offset = 1;
              break;
            case "ArrowUp":
              offset = menuItemCount - 1;
              break;
            case "ArrowLeft":
              offset = menuItemCount - menuItemsPerCol;
              break;
            case "ArrowRight":
              offset = menuItemsPerCol;
              break;
            default:
              return;
          }
          selected = (selected + offset) % menuItemCount;
        });

        gfx.canvas.addEventListener("click", () => {
          selected = (selected + 1) % menuItemCount;
        });
      }

      function demoSelection() {
        const select = document.getElementById("select");
        const options = {
          "Alarm UI": ui,
          Flagge: flag,
          "Ball animation": bouncingBallDemo,
          "Text animation": scrollingTextDemo,
          Regenbogen: rainbowDemo,
        };

        // Populate select
        Object.keys(options).forEach((name) => {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          select.appendChild(opt);
        });

        // Run selected demo
        function runSelected() {
          const fn = options[select.value];
          if (typeof fn === "function") fn();
        }

        select.addEventListener("change", runSelected);

        // Initial selection
        if (select.options.length) {
          select.selectedIndex = 0;
          runSelected();
        }
      }

      const fontFile = new FontFace(
        "Micro5",
        'url("https://fonts.gstatic.com/s/micro5/v2/H4cnBX2MkcfEngTr4gEa7Q.woff2")',
      );
      document.fonts.add(fontFile);

      fontFile.load().then(
        () => {
          demoSelection();
        },
        (err) => {
          console.error(err);
        },
      );
    </script>
  </body>
</html>
